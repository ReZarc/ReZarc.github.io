<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="&#x2F;&#x2F;（因为没人看所以防丢）">
<meta property="og:type" content="article">
<meta property="og:title" content="自用板子">
<meta property="og:url" content="http://example.com/2021/08/23/%E6%9D%BF%E5%AD%90/index.html">
<meta property="og:site_name" content="Rezarc&#39;s Blog">
<meta property="og:description" content="&#x2F;&#x2F;（因为没人看所以防丢）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-23T04:15:52.000Z">
<meta property="article:modified_time" content="2021-12-11T13:24:27.938Z">
<meta property="article:author" content="Reza Kung">
<meta property="article:tag" content="基础算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/08/23/%E6%9D%BF%E5%AD%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>自用板子 | Rezarc's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rezarc's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">HELLO WORLD</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="link fa-fw"></i>友链</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/23/%E6%9D%BF%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Reza Kung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rezarc's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自用板子
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-23 12:15:52" itemprop="dateCreated datePublished" datetime="2021-08-23T12:15:52+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-11 21:24:27" itemprop="dateModified" datetime="2021-12-11T21:24:27+08:00">2021-12-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>//（因为没人看所以防丢）</p>
<span id="more"></span>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; =  r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(q, l, mid);</span><br><span class="line">  <span class="built_in">merge</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; =  mid &amp;&amp; j &lt; =  r)</span><br><span class="line">    <span class="keyword">if</span> (q[i] &lt; =  q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; =  mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">  <span class="keyword">while</span> (j &lt; =  r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">  <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt; =  r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精加法"><a href="#高精加法" class="headerlink" title="高精加法"></a>高精加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A,vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||i&lt;B.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+ = A[i];</span><br><span class="line">      <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+ = B[i];</span><br><span class="line">      C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">      t/ = <span class="number">10</span>;</span><br><span class="line">   	&#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="高精减法"><a href="#高精减法" class="headerlink" title="高精减法"></a>高精减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;A,vector&lt;<span class="keyword">int</span>&gt;&amp;B)</span></span>&#123;     <span class="comment">//判断AB谁大</span></span><br><span class="line">  <span class="keyword">if</span>(A.<span class="built_in">size</span>()! = B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt; = <span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">if</span>(A[i]! = B[i]) <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A,vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    t = A[i]-t;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t- = B[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>() = = <span class="number">0</span>) C.<span class="built_in">pop_back</span>();         <span class="comment">//去前导零</span></span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="高精乘法"><a href="#高精乘法" class="headerlink" title="高精乘法"></a>高精乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">div</span>(vector&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">  r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt; = <span class="number">0</span>;i--)&#123;</span><br><span class="line">     r = r*<span class="number">10</span>+A[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">    r% = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>() = = <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高精除法"><a href="#高精除法" class="headerlink" title="高精除法"></a>高精除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">div</span>(vector&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">  r = <span class="number">0</span>;                <span class="comment">//余数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt; = <span class="number">0</span>;i--)&#123;</span><br><span class="line">    r = r*<span class="number">10</span>+A[i];</span><br><span class="line">     C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">     r% = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>() = = <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> C = <span class="built_in">F</span>(A,B);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt; = <span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">     <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;  <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">     <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">     <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">     <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;  <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">     <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">     <span class="keyword">else</span> l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">S[i] = S[i<span class="number">-1</span>]+a[i];<span class="comment">//(i&gt; = 2)</span></span><br><span class="line">a[l]+a[l+<span class="number">1</span>]+…+a[r] = S[r]-S[l<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>



<h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>S[i, j] = 第i行j列格子左上部分所有元素的和</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>



<h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>给区间[l, r]中的每个数加上c：B[l] + =  c, B[r + 1] - =  c</p>
<h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p>
<p>S[x1, y1] + =  c, S[x2 + 1, y1] - =  c, S[x1, y2 + 1] - =  c, S[x2 + 1, y2 + 1] + =  c;</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>求n的第k位数字: n &gt;&gt; k &amp; 1</p>
<p>返回n的最后一位1：lowbit(n) = n &amp; -n</p>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx; 	<span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; head = <span class="number">-1</span>;idx = <span class="number">0</span>;&#125;	<span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;	<span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123; head = ne[head]; &#125;	<span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br></pre></td></tr></table></figure>



<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">  r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  e[idx] = x;</span><br><span class="line">  l[idx] = a, r[idx] = r[a];</span><br><span class="line">  l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  l[r[a]] = l[a];</span><br><span class="line">  r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stk[N], tt = <span class="number">0</span>;  <span class="comment">// tt表示栈顶</span></span><br><span class="line">stk[ ++ tt] = x;    <span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">tt -- ;   <span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">stk[tt];   <span class="comment">// 栈顶的值</span></span><br><span class="line"><span class="keyword">if</span> (tt)    <span class="comment">// 判断栈是否为空</span></span><br></pre></td></tr></table></figure>



<h1 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;    <span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line">q[ ++ tt] = x;  <span class="comment">// 向队尾插入一个数</span></span><br><span class="line">hh ++ ;     <span class="comment">// 从队头弹出一个数</span></span><br><span class="line">q[hh];   <span class="comment">// 队头的值</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt; =  tt) <span class="comment">// 判断队列是否为空</span></span><br></pre></td></tr></table></figure>



<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;    <span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line">q[tt ++ ] = x;	<span class="comment">// 向队尾插入一个数</span></span><br><span class="line"><span class="keyword">if</span> (tt = =  N) tt = <span class="number">0</span>;	</span><br><span class="line">hh ++ ;	<span class="comment">// 从队头弹出一个数</span></span><br><span class="line"><span class="keyword">if</span> (hh = =  N) hh = <span class="number">0</span>;</span><br><span class="line">q[hh];	<span class="comment">// 队头的值</span></span><br><span class="line"><span class="keyword">if</span> (hh ! =  tt)	<span class="comment">// 判断队列是否为空</span></span><br></pre></td></tr></table></figure>



<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">  <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">  stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line">int hh = 0, tt = -1;</span><br><span class="line">for (int i = 0; i &lt; n; i ++ )&#123;</span><br><span class="line">  while (hh &lt; =  tt &amp;&amp; check_out(q[hh])) hh ++ ;// 判断队头是否滑出窗口</span><br><span class="line">  while (hh &lt; =  tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">  q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="下标从-1-开始"><a href="#下标从-1-开始" class="headerlink" title="下标从 1 开始"></a>下标从 1 开始</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">//求模式串的Next数组：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt; =  m; i ++ )&#123;</span><br><span class="line">  <span class="keyword">while</span> (j &amp;&amp; p[i] ! =  p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">  <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">  ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">  <span class="keyword">while</span> (j &amp;&amp; s[i] ! =  p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">  <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">  <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">     j = ne[j];</span><br><span class="line">     <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标从-0-开始"><a href="#下标从-0-开始" class="headerlink" title="下标从 0 开始"></a>下标从 0 开始</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string s,p;</span><br><span class="line">int ne[N];</span><br><span class="line">void get_next()&#123;      //最开始学的板子，下标从 0 开始</span><br><span class="line">  ne[0] = -1;</span><br><span class="line">   for (int i = 1, j = -1; i &lt; m; i ++ )&#123;</span><br><span class="line">     while (j &gt; =  0 &amp;&amp; p[j + 1] ! =  p[i]) j = ne[j];</span><br><span class="line">     if (p[j + 1] = =  p[i]) j ++ ;</span><br><span class="line">     ne[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int kmp(string s, string p)&#123;</span><br><span class="line">     for (int i = 0, j = -1; i &lt; n; i ++ )&#123;</span><br><span class="line">     while (j ! =  -1 &amp;&amp; s[i] ! =  p[j + 1]) j = ne[j];</span><br><span class="line">     if (s[i] = =  p[j + 1]) j ++ ;</span><br><span class="line">     if (j = =  m - 1)&#123;</span><br><span class="line">       return i - j + 1;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">     <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">     <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">     p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">     <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">     <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h3 id="1-朴素并查集："><a href="#1-朴素并查集：" class="headerlink" title="(1)朴素并查集："></a>(1)朴素并查集：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ ) p[i] = i;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="2-维护size的并查集："><a href="#2-维护size的并查集：" class="headerlink" title="(2)维护size的并查集："></a>(2)维护size的并查集：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">   p[i] = i;</span><br><span class="line">   size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] + =  size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="3-维护到祖宗节点距离的并查集："><a href="#3-维护到祖宗节点距离的并查集：" class="headerlink" title="(3)维护到祖宗节点距离的并查集："></a>(3)维护到祖宗节点距离的并查集：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> p[x] = =  x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">   p[i] = i; d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>



<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">  <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">  <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t = u;</span><br><span class="line">  <span class="keyword">if</span> (u * <span class="number">2</span> &lt; =  size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt; =  size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (u ! =  t)&#123;</span><br><span class="line">     <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">     <span class="built_in">down</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])&#123;</span><br><span class="line">      <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">     u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>





<p>Priority_queue&lt;int,vector<int>, greater<int>&gt; q; //小根堆</p>
<p>priority_queue<int> q; //大根堆</p>
<h1 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h1><p>(1) 拉链法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">     <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">     e[idx] = x;</span><br><span class="line">     ne[idx] = h[k];</span><br><span class="line">     h[k] = idx ++ ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;   <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">     <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i ! =  <span class="number">-1</span>; i = ne[i])</span><br><span class="line">       <span class="keyword">if</span> (e[i] = =  x)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 开放寻址法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">   <span class="keyword">while</span> (h[t] ! =  null &amp;&amp; h[t] ! =  x)&#123;</span><br><span class="line">     t ++ ;</span><br><span class="line">     <span class="keyword">if</span> (t = =  N) t = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">  h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">  p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">  <span class="built_in">size</span>() 返回元素个数</span><br><span class="line">  <span class="built_in">empty</span>() 返回是否为空</span><br><span class="line">  <span class="built_in">clear</span>() 清空</span><br><span class="line">  <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">  <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">  <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">  []</span><br><span class="line">  支持比较运算，按字典序</span><br><span class="line">  </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">  first, 第一个元素</span><br><span class="line">  second, 第二个元素</span><br><span class="line">  支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">  <span class="built_in">size</span>()/<span class="built_in">length</span>() 返回字符串长度</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">clear</span>()</span><br><span class="line">  <span class="built_in">substr</span>(起始下标，(子串长度)) 返回子串</span><br><span class="line">  <span class="built_in">c_str</span>() 返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">  <span class="built_in">size</span>()</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">push</span>() 向队尾插入一个元素</span><br><span class="line">  <span class="built_in">front</span>() 返回队头元素</span><br><span class="line">  <span class="built_in">back</span>() 返回队尾元素</span><br><span class="line">  <span class="built_in">pop</span>() 弹出队头元素</span><br><span class="line">  </span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">  <span class="built_in">size</span>()</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">push</span>() 插入一个元素</span><br><span class="line">  <span class="built_in">top</span>() 返回堆顶元素</span><br><span class="line">  <span class="built_in">pop</span>() 弹出堆顶元素</span><br><span class="line">  定义成小根堆的方式：priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">  <span class="built_in">size</span>()</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">push</span>() 向栈顶插入一个元素</span><br><span class="line">  <span class="built_in">top</span>() 返回栈顶元素</span><br><span class="line">  <span class="built_in">pop</span>() 弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">  <span class="built_in">size</span>()</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">clear</span>()</span><br><span class="line">  <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">  <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">  <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">  <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">  []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">  <span class="built_in">size</span>()</span><br><span class="line">  <span class="built_in">empty</span>()</span><br><span class="line">  <span class="built_in">clear</span>()</span><br><span class="line">  <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">  ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line">  </span><br><span class="line">set/<span class="function">multiset</span></span><br><span class="line"><span class="function">     <span class="title">insert</span><span class="params">()</span> 插入一个数</span></span><br><span class="line"><span class="function">     <span class="title">find</span><span class="params">()</span> 查找一个数</span></span><br><span class="line"><span class="function">     <span class="title">count</span><span class="params">()</span> 返回某一个数的个数</span></span><br><span class="line"><span class="function">     <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x  <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">       <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">     <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       <span class="title">lower_bound</span><span class="params">(x)</span> 返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">       <span class="title">upper_bound</span><span class="params">(x)</span> 返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">map/multimap</span></span><br><span class="line"><span class="function">     <span class="title">insert</span><span class="params">()</span> 插入的数是一个pair</span></span><br><span class="line"><span class="function">     <span class="title">erase</span><span class="params">()</span> 输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">     <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     [] 注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">     <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">  和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">  不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">  bitset&lt;10000&gt; s</span>;</span><br><span class="line">  ~, &amp;, |, ^</span><br><span class="line">  \&gt;&gt;, &lt;&lt;</span><br><span class="line">   = = , ! = </span><br><span class="line">  []</span><br><span class="line">  <span class="built_in">count</span>() 返回有多少个<span class="number">1</span></span><br><span class="line">  <span class="built_in">any</span>() 判断是否至少有一个<span class="number">1</span></span><br><span class="line">  <span class="built_in">none</span>() 判断是否全为<span class="number">0</span></span><br><span class="line">  <span class="built_in">set</span>() 把所有位置成<span class="number">1</span></span><br><span class="line">  <span class="built_in">set</span>(k, v) 将第k位变成v</span><br><span class="line">  <span class="built_in">reset</span>() 把所有位变成<span class="number">0</span></span><br><span class="line">  <span class="built_in">flip</span>() 等价于~</span><br><span class="line">  <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>



<h1 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h1><p>树是一种特殊的图，与图的存储方式相同。</p>
<p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p>
<p>因此我们可以只考虑有向图的存储。</p>
<p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b</p>
<p>(2) 邻接表：</p>
<p>// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</p>
<p>int h[N], e[N], ne[N], idx;</p>
<p>void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}   // 添加一条边a-&gt;b</p>
<p>idx = 0; mem (h, -1);  // 初始化</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">     <span class="keyword">int</span> j = e[i];</span><br><span class="line">     <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">         <span class="keyword">int</span> j = e[i];</span><br><span class="line">         <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">           st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">           q.<span class="built_in">push</span>(j);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">     <span class="keyword">if</span> (!d[i])</span><br><span class="line">     q[ ++ tt] = i;</span><br><span class="line">  <span class="keyword">while</span> (hh &lt;=  tt)&#123;</span><br><span class="line">     <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i !=  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">       <span class="keyword">int</span> j = e[i];</span><br><span class="line">       <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">         q[ ++ tt] = j;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">  <span class="keyword">return</span> tt ==  n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="朴素dijkstra"><a href="#朴素dijkstra" class="headerlink" title="朴素dijkstra"></a>朴素dijkstra</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dis[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];  <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">     <span class="keyword">int</span> t = <span class="number">-1</span>;   <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; =  n; j ++ )</span><br><span class="line">       <span class="keyword">if</span> (!st[j] &amp;&amp; (t = =  <span class="number">-1</span> || dis[t] &gt; dis[j]))</span><br><span class="line">         t = j;</span><br><span class="line">     <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; =  n; j ++ )</span><br><span class="line">       dis[j] = <span class="built_in">min</span>(dis[j], dis[t] + g[t][j]);</span><br><span class="line">     st[t] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dis[n] = =  <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="堆优化dijkstra"><a href="#堆优化dijkstra" class="headerlink" title="堆优化dijkstra"></a>堆优化dijkstra</h1><p>时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n;   <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;    <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dis[N];    <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">  heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);   <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line">  <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">     <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">     <span class="keyword">int</span> ver = t.second, disance = t.first;</span><br><span class="line">     <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">     st[ver] = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">       <span class="keyword">int</span> j = e[i];</span><br><span class="line">       <span class="keyword">if</span> (dis[j] &gt; disance + w[i])&#123;</span><br><span class="line">         dis[j] = disance + w[i];</span><br><span class="line">         heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dis[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;    <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> dis[N];    <span class="comment">// dis[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>   <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">  <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">       <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">       <span class="keyword">if</span> (dis[b] &gt; dis[a] + w)</span><br><span class="line">         dis[b] = dis[a] + w;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dis[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;   <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;    <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dis[N];    <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis); dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st);</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>); st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">     <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">     q.<span class="built_in">pop</span>();</span><br><span class="line">     st[t] = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">       <span class="keyword">int</span> j = e[i];</span><br><span class="line">       <span class="keyword">if</span> (dis[j] &gt; dis[t] + w[i])&#123;</span><br><span class="line">         dis[j] = dis[t] + w[i];</span><br><span class="line">         <span class="keyword">if</span> (!st[j])   <span class="comment">// 如果队列中已存在j，则不需要将j重复插入 &#123;</span></span><br><span class="line">           q.<span class="built_in">push</span>(j);</span><br><span class="line">           st[j] = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dis[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h1><p>时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;   <span class="comment">// 总点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;    <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], cnt[N];    <span class="comment">// dis[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 不需要初始化dis数组</span></span><br><span class="line">  <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ ) &#123;</span><br><span class="line">     q.<span class="built_in">push</span>(i);</span><br><span class="line">     st[i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">     <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">     q.<span class="built_in">pop</span>();</span><br><span class="line">     st[t] = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">       <span class="keyword">int</span> j = e[i];</span><br><span class="line">       <span class="keyword">if</span> (dis[j] &gt; dis[t] + w[i])&#123;</span><br><span class="line">         dis[j] = dis[t] + w[i];</span><br><span class="line">         cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (cnt[j] &gt; =  n) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">         <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">           q.<span class="built_in">push</span>(j);</span><br><span class="line">           st[j] = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="最小生成树-Kruskal"><a href="#最小生成树-Kruskal" class="headerlink" title="最小生成树 - Kruskal"></a>最小生成树 - Kruskal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;    <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];    <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>   // 存储边&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, b, w;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// 并查集核心操作</span></span><br><span class="line"> 	<span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=  n; i ++ ) p[i] = i;  <span class="comment">// 初始化并查集</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">     <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">     a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">     <span class="keyword">if</span> (a != b) &#123;   <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">       p[a] = b;</span><br><span class="line">       res +=  w;</span><br><span class="line">       cnt ++ ;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="最小生成树-Prim"><a href="#最小生成树-Prim" class="headerlink" title="最小生成树 - Prim"></a>最小生成树 - Prim</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, g[N][N], dis[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">mem</span>(dis,INF);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">     <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">       <span class="keyword">if</span>(!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[t] &gt; dis[j])) </span><br><span class="line">         t = j;</span><br><span class="line">     <span class="keyword">if</span>(i &amp;&amp; dis[t] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">if</span>(i) ans += dis[t];</span><br><span class="line">     vis[t] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j ++) dis[j] = <span class="built_in">min</span>(dis[j], g[t][j]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h1><p>时间复杂度是 O(n+m)O(n+m), n 表示点数，m 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;   <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;   <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];    <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">  color[u] = c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">     <span class="keyword">int</span> j = e[i];</span><br><span class="line">     <span class="keyword">if</span> (color[j] = =  <span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (color[j] = =  c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n; i ++ )</span><br><span class="line">     <span class="keyword">if</span> (color[i] = =  <span class="number">-1</span>)</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))&#123;</span><br><span class="line">         flag = <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>时间复杂度是 O(nm)O(nm), n 表示点数，m 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;   <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> match[N];    <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i ! =  <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">     <span class="keyword">int</span> j = e[i];</span><br><span class="line">     <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">       st[j] = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (match[j] = =  <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123;</span><br><span class="line">         match[j] = x;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  n1; i ++ )&#123;</span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=  x / i; i ++ )</span><br><span class="line">     <span class="keyword">if</span> (x % i = =  <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x % i = =  <span class="number">0</span>) x / =  i, s ++ ;</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="朴素素数筛"><a href="#朴素素数筛" class="headerlink" title="朴素素数筛"></a>朴素素数筛</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;   <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">     <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">     primes[cnt ++ ] = i;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; =  n; j + =  i)</span><br><span class="line">       st[j] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线性筛求素数"><a href="#线性筛求素数" class="headerlink" title="线性筛求素数"></a>线性筛求素数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;   <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; =  n; i ++ )&#123;</span><br><span class="line">     <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt; =  n / i; j ++ )&#123;</span><br><span class="line">       st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (i % primes[j] = =  <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =  x / i; i ++ )</span><br><span class="line">     <span class="keyword">if</span> (x % i = =  <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       res.<span class="built_in">push_back</span>(i);</span><br><span class="line">       <span class="keyword">if</span> (i ! =  x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure>



<h1 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h1><p>欧拉函数是小于n的正整数中与n互质的数的数目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; =  x / i; i ++ )</span><br><span class="line">     <span class="keyword">if</span> (x % i = =  <span class="number">0</span>)&#123;</span><br><span class="line">       res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">while</span> (x % i = =  <span class="number">0</span>) x / =  i;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;   <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];      <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">     <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">       primes[cnt ++ ] = i;</span><br><span class="line">       euler[i] = i - <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">       <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">       st[t] = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">         euler[t] = euler[i] * primes[j];</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">     x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">  y -= (a/b) * x;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c, r;</span><br><span class="line">  <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )&#123;</span><br><span class="line">     <span class="keyword">int</span> t = r;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )  <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">         t = i;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);  <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];   <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )    <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">           a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">     r ++ ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; n)&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">       a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h1><ol>
<li>递归法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">     <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure>

<p>\2.   预处理逆元求组合数<br>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>  <span class="comment">// 快速幂模板&#123;</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> res </span>= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )&#123;</span><br><span class="line">  fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">  infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><p>若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：</p>
<p>C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// 快速幂模板</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">    	<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">    	a = (LL)a * a % p;</span><br><span class="line">    	k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// 通过定理求组合数C(a, b)</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>; <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ ) &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">	<span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)</p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>求 m^k mod p，时间复杂度 O(logk)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">  <span class="keyword">while</span> (k)&#123;</span><br><span class="line">     <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">     t = t * t % p;</span><br><span class="line">     k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Ex-KMP"><a href="#Ex-KMP" class="headerlink" title="Ex - KMP"></a>Ex - KMP</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;             <span class="comment">//字符串长度最大值</span></span><br><span class="line"><span class="keyword">int</span> pre[N],ext[N];               <span class="comment">// ext 指 s 与 p 的最长公共前缀</span></span><br><span class="line">string s,t;                  <span class="comment">//pre 是 x 的最长公共前后缀</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpre</span><span class="params">(string s)</span></span>&#123;             <span class="comment">// 求 pre 数组</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>,j,pos, m = s.<span class="built_in">size</span>();</span><br><span class="line">  pre[<span class="number">0</span>] = m;                <span class="comment">//用自己来做后缀与自己匹配</span></span><br><span class="line">  <span class="keyword">while</span>(s[i] == s[i+<span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; m) i ++;  <span class="comment">//求pre[1]</span></span><br><span class="line">  pre[<span class="number">1</span>] = i; pos = <span class="number">1</span>;            <span class="comment">//从此点出发 pre 延伸最远</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; m;i ++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(pre[i - pos] &lt; pre[pos] + pos - i)</span><br><span class="line">		pre[i] = pre[i - pos]; <span class="comment">//第一种情况，可以直接得pre[i]</span></span><br><span class="line">    <span class="keyword">else</span> &#123;                 <span class="comment">//第二种情况，继续匹配才能得到pre[i]</span></span><br><span class="line">      j = pre[pos] + pos - i;         </span><br><span class="line">      j = <span class="built_in">max</span>(j,<span class="number">0</span>);     <span class="comment">//小于0 时没有已知相同部分，重新开始匹配</span></span><br><span class="line">      <span class="keyword">while</span>(i + j &lt; m &amp;&amp; s[j] == s[j + <span class="number">1</span>]) j ++;</span><br><span class="line">      pre[i] = j; pos = i;              <span class="comment">//更新pos</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exkmp</span><span class="params">(string s,string t)</span></span>&#123;        <span class="comment">//求 ext 数组</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j, pos, l = s.<span class="built_in">size</span>(), q = t.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">getpre</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(s[i] == t[i] &amp;&amp; i &lt; q &amp;&amp; i &lt; l) i++;</span><br><span class="line">  ext[<span class="number">0</span>] = i; pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; l; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[i - pos] + i &lt; ext[pos] + pos) ext[i] = pre[i - pos];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      j = ext[pos] + pos - i;</span><br><span class="line">      j = <span class="built_in">max</span>(j,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span>(i + j &lt; l &amp;&amp; j &lt; q &amp;&amp; s[j + <span class="number">1</span>] == t[j]) j++;</span><br><span class="line">      ext[i] = j; pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">子串匹配</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">    <span class="keyword">if</span>(s[i + j - <span class="number">1</span>] != p[j])&#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">后缀和前缀相等的长度 --- Next数组</span><br><span class="line">Next[i] = j;  --p[<span class="number">1</span> --&gt; j] = p[i - j + <span class="number">1</span> ---&gt; i]</span><br></pre></td></tr></table></figure>





<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="keyword">int</span> len[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = s.<span class="built_in">size</span>();</span><br><span class="line">  t[<span class="number">0</span>] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span> * l; i += <span class="number">2</span>)&#123;</span><br><span class="line">     t[i] = <span class="string">&#x27;#&#x27;</span>; t[i + <span class="number">1</span>] = s[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  t += “#$”; t += <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> maxx = <span class="number">0</span>, pos = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;t[i]; i ++)&#123;</span><br><span class="line">     len[i] = (maxx &gt; i ? <span class="built_in">min</span>(maxx - i,len[(pos &lt;&lt; <span class="number">1</span>) - i]) : <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) len[i] ++ ;</span><br><span class="line">     <span class="keyword">if</span>(len[i] + i &gt; maxx) maxx = len[i] + i, pos = i;</span><br><span class="line">     ans = <span class="built_in">max</span>(ans, len[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="博弈-巴什博奕"><a href="#博弈-巴什博奕" class="headerlink" title="博弈 - 巴什博奕"></a>博弈 - 巴什博奕</h1><p>有一堆石子n个 , 每次可以取1~m个石子 , 没有石子可取的那方输 , 问第一个取的人的输赢</p>
<p>n % (m+1) != 0先手赢</p>
<p>变形：最后取的输 (n-1)%(m+1) != 0</p>
<h1 id="博弈-–-威佐夫博弈"><a href="#博弈-–-威佐夫博弈" class="headerlink" title="博弈 – 威佐夫博弈"></a>博弈 – 威佐夫博弈</h1><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>
<p>我们用 ( a [ k ] ， b [ k ] ) (a[k]，b[k]) (a[k]，b[k])表示两堆物品的数量并称其为局势，显然(0，0)为必输局势，这种必输局势我们称为奇异局势。</p>
<p>前几个奇异局势是：（0，0）,（1，2）,（3，5）,（4，7）,（6，10）,（8，13）,（9，15）,（11，18）,（12，20）</p>
<p>奇异局势判断 :</p>
<p>直接判断小的那堆能不能写成上面a的公式 ( k = b − a )</p>
<p>a[k]=[k(1+√5)/2],b[k]=a[k]+k</p>
<h1 id="博弈-–-Nim博弈"><a href="#博弈-–-Nim博弈" class="headerlink" title="博弈 – Nim博弈"></a>博弈 – Nim博弈</h1><p>有k堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>
<p>如果k堆全部异或结果 == 0 则先手必败，否则先手必胜</p>
<h1 id="博弈-–-Fibonacci博弈"><a href="#博弈-–-Fibonacci博弈" class="headerlink" title="博弈 – Fibonacci博弈"></a>博弈 – Fibonacci博弈</h1><p>有一堆石子,两个人轮流从其中取走一定的石子,取走最后所有石子的人为赢家,不过得遵循如下规则:</p>
<p>1.第一次取不能取完,至少取1颗.</p>
<p>2.从第二次开始,每个人取的石子数至少为1,至多为对手刚取的石子数的两倍。</p>
<p>当n为Fibonacci数时，先手必败。否则先手必胜</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc i &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc i &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w, f;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<h2 id="pushup-amp-amp-pushdown"><a href="#pushup-amp-amp-pushdown" class="headerlink" title="pushup &amp;&amp; pushdown"></a>pushup &amp;&amp; pushdown</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;e[i].w = e[lc].w + e[rc].w;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    e[lc].f += e[i].f;</span><br><span class="line">    e[rc].f += e[i].f;</span><br><span class="line">    e[lc].w += e[i].f * (e[lc].r - e[lc].l + <span class="number">1</span>);</span><br><span class="line">    e[rc].w += e[i].f * (e[rc].r - e[rc].l + <span class="number">1</span>);</span><br><span class="line">    e[i].f = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    e[i].l = l, e[i].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        cin &gt;&gt; e[i].w;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, mid); <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == p) tr[u].d += v, tr[u].v += v;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, p, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="区间求和"><a href="#区间求和" class="headerlink" title="区间求和"></a>区间求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e[i].l &gt;= l &amp;&amp; e[i].r &lt;= r)&#123;</span><br><span class="line">        e[i].w += x * (e[i].r - e[i].l + <span class="number">1</span>);</span><br><span class="line">        e[i].f += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e[i].f) <span class="built_in">pushdown</span>(i);</span><br><span class="line">    <span class="keyword">int</span> mid = e[i].l + e[i].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">change</span>(lc, l, r, x);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">change</span>(rc, l, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e[i].l &gt;= l &amp;&amp; e[i].r &lt;= r) <span class="keyword">return</span> e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(e[i].f) <span class="built_in">pushdown</span>(i);</span><br><span class="line">    <span class="keyword">int</span> mid = e[i].l + e[i].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans += <span class="built_in">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans += <span class="built_in">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nValue,nKind;</span><br><span class="line"> <span class="comment">//0-1 背包，代价为 cost, 获得的价值为 weight</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=nValue;i&gt;=cost;i−−)</span><br><span class="line"> 		dp[i]=<span class="built_in">max</span>(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//完全背包，代价为 cost, 获得的价值为 weight</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=cost;i&lt;=nValue;i++)</span><br><span class="line">		dp[i]=<span class="built_in">max</span>(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//多重背包</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> weight,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cost*amount&gt;=nValue) <span class="built_in">CompletePack</span>(cost,weight);</span><br><span class="line"> 	<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"> 		<span class="keyword">while</span>(k&lt;amount)&#123;</span><br><span class="line">            <span class="built_in">ZeroOnePack</span>(k*cost,k*weight);</span><br><span class="line">            amount−=k;</span><br><span class="line">            k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">ZeroOnePack</span>(amount*cost,amount*weight);<span class="comment">//这个不要忘记了，经常掉了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分组背包：</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> to K</span><br><span class="line">    <span class="keyword">for</span> v = V to <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item i in group k</span><br><span class="line">        	F[v] = maxF[v],F[v-C[i]]+W</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="LCA-Tarjan离线"><a href="#LCA-Tarjan离线" class="headerlink" title="LCA - Tarjan离线"></a>LCA - Tarjan离线</h1> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">给出一颗有向树，Q 个查询</span><br><span class="line"> 输出查询结果中每个点出现次数</span><br><span class="line"><span class="comment">/*离线算法，LCATarjan</span></span><br><span class="line"><span class="comment"> 复杂度O(n+Q);*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">500010</span>;<span class="comment">//查询数的最大值</span></span><br><span class="line"><span class="comment">//并查集部分</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];<span class="comment">//需要初始化为 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> F[x] == x ? x ： F[x] = <span class="built_in">find</span>(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bing</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="built_in">find</span>(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">   	 	F[t1] = t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//访问标记</span></span><br><span class="line"><span class="keyword">int</span> ancestor[MAXN];<span class="comment">//祖先</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> q,next;</span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//查询编号</span></span><br><span class="line">&#125;query[MAXQ*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> answer[MAXQ];<span class="comment">//存储最后的查询结果，下标 0 Q-1</span></span><br><span class="line"><span class="keyword">int</span> h[MAXQ];</span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    query[tt].q = v;</span><br><span class="line">    query[tt].next = h[u];</span><br><span class="line">    query[tt].index = index;</span><br><span class="line">    h[u] = tt++;</span><br><span class="line">    query[tt].q = u;</span><br><span class="line">    query[tt].next = h[v];</span><br><span class="line">    query[tt].index = index;</span><br><span class="line">	h[v] = tt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(F,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(F));</span><br><span class="line">    <span class="built_in">memset</span>(ancestor,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ancestor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ancestor[u] = u;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i != −<span class="number">1</span>;i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">LCA</span>(v);</span><br><span class="line">        <span class="built_in">bing</span>(u,v);</span><br><span class="line">        ancestor[<span class="built_in">find</span>(u)] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u];i != −<span class="number">1</span>;i = query[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = query[i].q;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">        	answer[query[i].index] = ancestor[<span class="built_in">find</span>(v)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="keyword">int</span> Count_num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> u,v,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">memset</span>(flag,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(flag));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d:(%d)&quot;</span>,&amp;u,&amp;k);</span><br><span class="line">            <span class="keyword">while</span>(k−−)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">                flag[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">addedge</span>(u,v);</span><br><span class="line">                <span class="built_in">addedge</span>(v,u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Q;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch;</span><br><span class="line">            cin&gt;&gt;ch;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d␣%d)&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">add_query</span>(u,v,i);</span><br><span class="line"> 		&#125;</span><br><span class="line">         <span class="keyword">int</span> root;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">         <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">         root = i;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">LCA</span>(root);</span><br><span class="line">    <span class="built_in">memset</span>(Count_num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Count_num));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Q;i++)</span><br><span class="line">    Count_num[answer[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">if</span>(Count_num[i] &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,i,Count_num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Tarjan-求强连通分量"><a href="#Tarjan-求强连通分量" class="headerlink" title="Tarjan 求强连通分量"></a>Tarjan 求强连通分量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], scc, siz[N], stk[N], timest, id[N];</span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"><span class="keyword">int</span> dout[N];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;e[idx] = b; ne[idx] = h[a]; h[a] = idx ++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timest;            <span class="comment">//标记点时间戳  从 1 开始</span></span><br><span class="line">    sta.<span class="built_in">push</span>(u); stk[u] = <span class="number">1</span>;                <span class="comment">//入栈并标记下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;       <span class="comment">//遍历所有邻点</span></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])&#123;                        <span class="comment">//j 未被遍历过            </span></span><br><span class="line">            <span class="built_in">tarjan</span>(j);                      <span class="comment">//跑一遍tarjan</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);   <span class="comment">//low[j]维护最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]);   <span class="comment">//否则dfn[j]维护最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])&#123;                   <span class="comment">//找到最高点</span></span><br><span class="line">        scc ++;                             </span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            t = sta.<span class="built_in">top</span>(); sta.<span class="built_in">pop</span>();       <span class="comment">//取出所有sta</span></span><br><span class="line">            stk[t] = <span class="number">0</span>;</span><br><span class="line">            id[t] = scc;                    <span class="comment">//标记属于哪个</span></span><br><span class="line">            siz[scc] ++;                    <span class="comment">//scc.size() ++;</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(t != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br></pre></td></tr></table></figure>



<h1 id="RMQ-区间最值查询"><a href="#RMQ-区间最值查询" class="headerlink" title="RMQ 区间最值查询"></a>RMQ 区间最值查询</h1><h3 id="预处理-O-nlogn"><a href="#预处理-O-nlogn" class="headerlink" title="预处理         O(nlogn)"></a>预处理         O(nlogn)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i ++) dp[i][<span class="number">0</span>]=a[i];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; j) &lt;= N;j ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N;i ++)</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-O-1"><a href="#查询-O-1" class="headerlink" title="查询        O(1)"></a>查询        O(1)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">log2</span>(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;   <span class="comment">//n 为字符串长度，m 为基数排序最大值</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], x[N], y[N], c[N], rk[N], height[N];</span><br><span class="line"><span class="comment">//x--存储第一关键字</span></span><br><span class="line"><span class="comment">//y--存储第二关键字</span></span><br><span class="line"><span class="comment">//c--存储每个数值的数目</span></span><br><span class="line"><span class="comment">//rk--rk[i]表示从i开始的后缀的排名</span></span><br><span class="line"><span class="comment">//sa--sa[i]表示排名为i的后缀的起始下标</span></span><br><span class="line"><span class="comment">//h--h[i]表示排名为i的后缀和排名为i - 1的后缀的最长前缀 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) c[x[i] = s[i]] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i ++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i --) sa[c[x[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先按照第二关键字排序，下标从i开始的后缀的第二关键字为从i+k开始的第一关键字 </span></span><br><span class="line">        <span class="comment">//先将无第二关键字的后缀排先名，此时y[i]表示按照第二关键字排名为i的起始下标 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k + <span class="number">1</span>;i &lt;= n;i ++) y[ ++ num] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="comment">//上一层循环中按照第一关键字的排名的下标已经存在sa数组中</span></span><br><span class="line">            <span class="comment">//按从小到大顺序枚举sa数组可保证按照第一关键字从小到大</span></span><br><span class="line">            <span class="comment">//所有起始下标超过k才存在第二关键字</span></span><br><span class="line">            <span class="comment">//将所有存在第二关键字的后缀存储在y数组中，此时是按i + k的第一关键字，下标要-k </span></span><br><span class="line">            <span class="keyword">if</span>(sa[i] &gt; k)</span><br><span class="line">                y[++ num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) c[i] = <span class="number">0</span>;            <span class="comment">//将计数数组清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) c[x[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i ++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//y数组存储的是按照第二关键字从小到大排序后的后缀的起始下标 </span></span><br><span class="line">        <span class="comment">//i从大到小枚举即可保证按照第一关键字排序后依然是按照第二关键字排序后的相对顺序不变 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i --) sa[c[x[y[i]]] --] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">         <span class="comment">//将所有后缀离散化 </span></span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时y存储的是从i开始的后缀的第一关键字 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i ++) <span class="comment">//若当前后缀和排名前一位的后缀第一关键字和第二关键字相同则离散化后的数值相同，否则+1 </span></span><br><span class="line">            x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++ num;</span><br><span class="line">        <span class="keyword">if</span>(num == n) <span class="keyword">break</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">1</span>, k = <span class="number">0</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(k) k --;</span><br><span class="line">        <span class="comment">//j为排名前一位的起始下标 </span></span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++;</span><br><span class="line">        <span class="comment">//求最长相同前缀 </span></span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="主席树-区间第K小数"><a href="#主席树-区间第K小数" class="headerlink" title="主席树 - 区间第K小数"></a>主席树 - 区间第K小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0); cout.tie(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;e[N * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> root[N], idx;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(v), x) - v.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ++ idx;</span><br><span class="line">    <span class="keyword">if</span>(l == r) </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    e[i].l = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    e[i].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;     <span class="comment">//p 代表上一版本的线段树， x 代表插入的值</span></span><br><span class="line">    <span class="keyword">int</span> q = ++ idx;</span><br><span class="line">    e[q] = e[p];</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        e[q].cnt ++;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) </span><br><span class="line">        e[q].l = <span class="built_in">insert</span>(e[p].l, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        e[q].r = <span class="built_in">insert</span>(e[p].r, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    e[q].cnt = e[e[q].l].cnt + e[e[q].r].cnt;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">int</span> cnt = e[e[q].l].cnt - e[e[p].l].cnt;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= cnt) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(e[q].l, e[p].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(e[q].r, e[p].r, mid + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        v.<span class="built_in">pb</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(v));   <span class="comment">//离散化</span></span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(v)), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        a[i] = <span class="built_in">find</span>(a[i]);</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>, a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; v[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>, k)] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag"># 基础算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/09/KMP/" rel="prev" title="KMP入门">
      <i class="fa fa-chevron-left"></i> KMP入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/23/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="next" title="后缀数组">
      后缀数组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%8A%A0%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">高精加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%87%8F%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">高精减法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E4%B9%98%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">高精乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E9%99%A4%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">高精除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">2.5.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">3.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">3.1.</span> <span class="nav-text">整数二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86"><span class="nav-number">3.2.</span> <span class="nav-text">浮点二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">4.</span> <span class="nav-text">一维前缀和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">5.</span> <span class="nav-text">二维前缀和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">6.</span> <span class="nav-text">一维差分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">7.</span> <span class="nav-text">二维差分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">8.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">11.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97"><span class="nav-number">12.</span> <span class="nav-text">普通队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">13.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">14.</span> <span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">15.</span> <span class="nav-text">单调队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KMP"><span class="nav-number">16.</span> <span class="nav-text">KMP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E4%BB%8E-1-%E5%BC%80%E5%A7%8B"><span class="nav-number">16.1.</span> <span class="nav-text">下标从 1 开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E4%BB%8E-0-%E5%BC%80%E5%A7%8B"><span class="nav-number">16.2.</span> <span class="nav-text">下标从 0 开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Trie"><span class="nav-number">17.</span> <span class="nav-text">Trie</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">18.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%9A"><span class="nav-number">18.0.1.</span> <span class="nav-text">(1)朴素并查集：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%B4%E6%8A%A4size%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%9A"><span class="nav-number">18.0.2.</span> <span class="nav-text">(2)维护size的并查集：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%B4%E6%8A%A4%E5%88%B0%E7%A5%96%E5%AE%97%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%9A"><span class="nav-number">18.0.3.</span> <span class="nav-text">(3)维护到祖宗节点距离的并查集：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">19.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C"><span class="nav-number">20.</span> <span class="nav-text">一般哈希</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">21.</span> <span class="nav-text">字符串哈希</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-number">22.</span> <span class="nav-text">STL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">23.</span> <span class="nav-text">树与图的存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS"><span class="nav-number">24.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS"><span class="nav-number">25.</span> <span class="nav-text">BFS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">26.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0dijkstra"><span class="nav-number">27.</span> <span class="nav-text">朴素dijkstra</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96dijkstra"><span class="nav-number">28.</span> <span class="nav-text">堆优化dijkstra</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">29.</span> <span class="nav-text">Bellman-Ford算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spfa"><span class="nav-number">30.</span> <span class="nav-text">Spfa</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spfa%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B4%9F%E7%8E%AF"><span class="nav-number">31.</span> <span class="nav-text">spfa判断图中是否存在负环</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal"><span class="nav-number">32.</span> <span class="nav-text">最小生成树 - Kruskal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim"><span class="nav-number">33.</span> <span class="nav-text">最小生成树 - Prim</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%88%AB%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">34.</span> <span class="nav-text">染色法判别二分图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">35.</span> <span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="nav-number">36.</span> <span class="nav-text">试除法分解质因数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E7%B4%A0%E6%95%B0%E7%AD%9B"><span class="nav-number">37.</span> <span class="nav-text">朴素素数筛</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="nav-number">38.</span> <span class="nav-text">线性筛求素数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="nav-number">39.</span> <span class="nav-text">试除法求约数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="nav-number">40.</span> <span class="nav-text">辗转相除法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">41.</span> <span class="nav-text">求欧拉函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">42.</span> <span class="nav-text">筛法求欧拉函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">43.</span> <span class="nav-text">扩展欧几里得算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="nav-number">44.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">45.</span> <span class="nav-text">求组合数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86"><span class="nav-number">46.</span> <span class="nav-text">卢卡斯定理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="nav-number">47.</span> <span class="nav-text">卡特兰数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">48.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ex-KMP"><span class="nav-number">49.</span> <span class="nav-text">Ex - KMP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Manacher"><span class="nav-number">50.</span> <span class="nav-text">Manacher</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88-%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%A5%95"><span class="nav-number">51.</span> <span class="nav-text">博弈 - 巴什博奕</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88-%E2%80%93-%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88"><span class="nav-number">52.</span> <span class="nav-text">博弈 – 威佐夫博弈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88-%E2%80%93-Nim%E5%8D%9A%E5%BC%88"><span class="nav-number">53.</span> <span class="nav-text">博弈 – Nim博弈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88-%E2%80%93-Fibonacci%E5%8D%9A%E5%BC%88"><span class="nav-number">54.</span> <span class="nav-text">博弈 – Fibonacci博弈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">55.</span> <span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">55.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pushup-amp-amp-pushdown"><span class="nav-number">55.2.</span> <span class="nav-text">pushup &amp;&amp; pushdown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E6%A0%91"><span class="nav-number">55.3.</span> <span class="nav-text">建树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9"><span class="nav-number">55.4.</span> <span class="nav-text">单点修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C"><span class="nav-number">55.5.</span> <span class="nav-text">区间求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">55.6.</span> <span class="nav-text">区间查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E5%8C%85"><span class="nav-number">56.</span> <span class="nav-text">背包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LCA-Tarjan%E7%A6%BB%E7%BA%BF"><span class="nav-number">57.</span> <span class="nav-text">LCA - Tarjan离线</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tarjan-%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">58.</span> <span class="nav-text">Tarjan 求强连通分量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RMQ-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-number">59.</span> <span class="nav-text">RMQ 区间最值查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86-O-nlogn"><span class="nav-number">59.0.1.</span> <span class="nav-text">预处理         O(nlogn)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2-O-1"><span class="nav-number">59.0.2.</span> <span class="nav-text">查询        O(1)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="nav-number">60.</span> <span class="nav-text">后缀数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%8C%BA%E9%97%B4%E7%AC%ACK%E5%B0%8F%E6%95%B0"><span class="nav-number">61.</span> <span class="nav-text">主席树 - 区间第K小数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Reza Kung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Reza Kung</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">67k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/src/fireworks.js"></script>
    

</html>
